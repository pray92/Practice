'''
변수, 상수 개념
'''

# [1] : 파이썬 프로그래밍 언어에서 변수란?
# '변'하는 '수'
# 코드를 작성하는 과정에서 여러 유형의 데이터 값을 많이 사용
# 이 때 데이터 값을 담는 '바구니'

# [2] : 변수의 역할은?
# 적절히 사용함으로써 효율적으로 코딩을 짤 수 있게 하는 역할을 담당

# [3] : 파이썬 프로그래밍에서 상수란?
# 항상 변하지 않는 수
# 프로그램 실행 도중에 데이터 값이 바뀌지 않고 항상 고정된 값을 그대로 유지되는 것
# ex. 문자열, 숫자

# [4] : 파이 값과 중력가속도 값을 '상수'로 정의가 가능하기는 하나,
# 별도의 추가적인 코드를 작성을 통해 처리해야 함(const 불가)
# 따라서 네이밍(ex. 대문자)를 통해 구분하는 방식으로 가는 수 밖에 없음
PI = 3.14
GRAVITY = 9.8

'''
변수 선언, 할당
'''

# [5] : 변수 선언 및 변수 값 할당
# 파이썬은 변수를 선언 시, 메모리 공간을 예약하기 위해서 명시적으로 선언할 필요가 없음
# 따라서, 바로 변수명을 적어주고 값을 할당하면 자동으로 변수 선언 및 변수 값 할당이 이뤄짐
#
# 여기서 '=' 기호는 '같다'는 의미가 아닌 '할당' 또는 오른쪽의 값을 왼쪽에 '대입'한다는 의미
a = 100             # 정수 할당
b = 3.14            # 실수 할당
c = 'k'             # 문자 할당
d = 'Hello World'   # 문자열 할당, 따옴표든 쌍따옴표든 둘 다 적용

# 출력
print('[결과 출력]')
print('a :', a)
print('b :', b)
print('c :', c)
print('d :', d)
print(a, b, c, d)

# [6] : 변수 값 할당 시 여러 변수에 동시에 한개의 값을 할당하는 '다중 할당' 코드를 구현
# 파이썬은 기본적으로 하나의 값을 여러 개의 변수에 할당하여 저장시킬 수 있음
e = f = g = h = i = 100
print('[결과 출력]')
print(e, f, g, h, i)

'''
다중 변수, 할당, 다중 할당
'''

# [7] : 다중 할당
# 각 변수마다 튜플 type인, (100, 200) 저장
a = b = c = d = e = 100, 200
print('[결과 출력]')
print(a, b, c, d, e) # (100, 200), (100, 200), (100, 200), (100, 200), (100, 200)
print("Type a :", type(a))

# [8] : 다중 할당시 여러 개의 값을 여러 개의 변수에 '각각' 저장시키는 코드를 '한줄'로 구현
a, b, c, d, e = 100, 3.14, 'k', "korea", "'korea'",
print('[결과 출력]')
print('a, b, c, d, e 변수의 값은', a, b, c, d, e)

'''
문자열, 따옴표, 홑따옴표
'''

# [9] : 나는 엄마에게 말했다. "더 이상 '카레'는 먹기 싫어요!" <- 출력
# 내부가 '' 인 경우, 외부를 ""로, 반대도 적용
print('[결과 출력]')
print('나는 엄마에게 말했다. "더 이상 카레는 먹기 싫어요!"')		# "" 표시
print('나는 엄마에게 말했다. "더 이상 "카레"는 먹기 싫어요!"')		# "" 표시, 외부가 ''이면 몇 쌍이라도 ""표시 가능
print("나는 엄마에게 말했다. '더 이상 카레는 먹기 싫어요!'")		# '' 표시

# 외부가 ''일 때 내부에 ''표시를 하려면 \ 사용, 반대도 마찬가지
print('나는 엄마에게 말했다. "더 이상 \'카레\'는 먹기 싫어요!"')
print("나는 엄마에게 말했다. \"더 이상 '카레'는 먹기 싫어요!\"")

'''
변수, id, id 함수
'''

# [10] : id() 출력 값은?
# 객체의 고유 메모리 주소 값을 반환

a = 'C++'
print(a, '-->', id(a))

# a를 b에 할당하는 것이므로 같은 주소 값을 반환
b = a
print(b, '-->', id(b))

a = 'Python'

# a의 경우 다른 값이 할당되므로 주소 값도 변경됨
print(a, '-->', id(a))
# b의 경우 과거의 a를 가지고 있으므로 값과 주소 값이 유지됨
print(b, '-->', id(b))

c = [1, 2, 3]
print(c, '-->', id(c))
print(c[0], '-->', id(c[0]))
print(c[1], '-->', id(c[1]))
print(c[2], '-->', id(c[2]))

'''
is, is 연산자, 연산자
'''

# [11] : is 연산자를 이용한 출력 결과는?
a = [1, 2, 3, 4, 5]
b = a
c = [1, 2, 3, 4, 5]

# is는 ==연산자와 달리 값을 비교하는 것이 아닌 '주소'를 비교하는 것
print('a is b =', a is b)	# True
print('a is c =', a is c)	# False
print('b is c =', b is c)	# False

'''
is, ==, 연산자
'''

# [12] : ==연산자를 이용한 출력 결과
# ==는 값을 비교
print('a == b =', a == b)	# True
print('b == c =', a == b)	# True
print('a == c =', a == b)	# True
print('{0:=^10}'.format('hi'))

'''
is 연산자, 결과, print
'''

# [13] :  is, ==연산자의 결과로 출력되는 값을 예상
# NOTE: 상수는 특정 메모리에 저장됩니다.

# 숫자
a = 101
b = 100 + 1

print('[13-1] a is b = ', a is b)	# False -> True
print('[13-2] a == b = ', a == b)	# True

# 문자열
c = 'korea'
d = 'korea'

print('[13-3] c is d', c is d)	# True -> 
print('[13-4] c == d', c is d)	# True

# 리스트
e = [ 1, 2, 3, 4, 5]
f = [ 1, 2, 3, 4, 5]
print('[13-3] e is f', e is f)	# False
print('[13-4] e == f', e == f)	# True

# 메서드 반환 값도 같으면 주소 값이 동일
def temp():
	ret = 0
	for x in range(102):
		ret = ret + 1
	return ret

g = 102
h = temp()

print( g is h,g ==  h)